/////////////工具类/////////////////////////////////////////////////////
/**
 * 判断浏览器类型及版本
 * 
**/
var Browser = {
    init: function () {
    	var agent = navigator.userAgent;
        this.browser = (this.browserInfo(agent) + "").replace(/[0-9./]/ig, "");            //浏览器名称
        this.version = parseInt((this.browserInfo(agent) + "").replace(/[^0-9.]/ig, ""));  //浏览器版本
        this.cores = this.cores(agent);                                                    //浏览器内核
        this.language = (navigator.browserLanguage || navigator.language).toLowerCase(); //语言
    },
    browserInfo:function(agent){
    	var agent = agent.toLowerCase();
    	var regStr_ie = /msie [\d.]+;/gi;
    	var regStr_ff = /firefox\/[\d.]+/gi
    	var regStr_chrome = /chrome\/[\d.]+/gi;
    	var regStr_saf = /safari\/[\d.]+/gi;
    	var isIE = agent.indexOf("compatible") > -1 && agent.indexOf("msie" > -1); //判断是否IE<11浏览器  
    	var isEdge = agent.indexOf("edge") > -1 && !isIE; //判断是否IE的Edge浏览器  
    	var isIE11 = agent.indexOf('trident') > -1 && agent.indexOf("rv:11.0") > -1;
    	if (isIE) {
    		var reIE = new RegExp("msie (\\d+\\.\\d+);");
    		reIE.test(agent);
    		var fIEVersion = parseFloat(RegExp["$1"]);
    		if (fIEVersion == 7) {
    			return "IE/7";
    		} else if (fIEVersion == 8) {
    			return "IE/8";
    		} else if (fIEVersion == 9) {
    			return "IE/9";
    		} else if (fIEVersion == 10) {
    			return "IE/10";
    		}
    	} //isIE end 
    	if (isIE11) {
    		return "IE/11";
    	}
    	//firefox
    	if (agent.indexOf("firefox") > 0) {
    		return agent.match(regStr_ff);
    	}
    	//Safari
    	if (agent.indexOf("safari") > 0 && agent.indexOf("chrome") < 0) {
    		return agent.match(regStr_saf);
    	}
    	//Chrome
    	if (agent.indexOf("chrome") > 0) {
    		return agent.match(regStr_chrome);
    	}
    },
    cores:function(u){
           //var u = navigator.userAgent
            return {
              trident: u.indexOf('Trident') > -1, //IE内核
              presto: u.indexOf('Presto') > -1, //opera内核
              webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
              gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1,//火狐内核
                ff : u.indexOf("Firefox") > -1, //判断是否Firefox浏览器
              mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
              ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
              android: u.indexOf('Android') > -1 || u.indexOf('Adr') > -1, //android终端
              iPhone: u.indexOf('iPhone') > -1 , //是否为iPhone或者QQHD浏览器
              iPad: u.indexOf('iPad') > -1, //是否iPad
              webApp: u.indexOf('Safari') == -1, //是否web应该程序，没有头部与底部
              weixin: u.indexOf('MicroMessenger') > -1, //是否微信
              qq: u.match(/\sQQ/i) == " qq" //是否QQ
            };
      }
};
/**
 * 上报参数
 * @param objectParams json对象
 */
function submit(objectParams){
	if(objectParams != undefined){
		var params = Object.keys(objectParams).map(function (key) {
	        return encodeURIComponent(key) + "=" + encodeURIComponent(objectParams[key]);
	    }).join("&");
	    new Image().src=window.__bl.config.imgUrl+"pid="+window.__bl.config.pid+"&"+params
	}
}


/*
* 注册浏览器的DOMContentLoaded事件
* @param { Function } onready [必填]在DOMContentLoaded事件触发时需要执行的函数
* @param { Object } config [可选]配置项
*/
function onDOMContentLoaded(onready,config){
    //浏览器检测相关对象，在此为节省代码未实现，实际使用时需要实现。
    //var Browser = {};
	Browser.init();
    //设置是否在FF下使用DOMContentLoaded（在FF2下的特定场景有Bug）
    this.conf = {
        enableMozDOMReady:true
    };
    if( config )
        for( var p in config)
            this.conf[p] = config[p];
    var isReady = false;
    function doReady(){
        if( isReady ) return;
        //确保onready只执行一次
        isReady = true;
        onready();
    }
    /*IE*/
    if( Browser.browser=="IE" && Browser.version > 8 ){
        (function(){
            if ( isReady ) return;
            try {
                document.documentElement.doScroll("left");
            } catch( error ) {
                setTimeout( arguments.callee, 0 );
                return;
            }
            doReady();
        })();
        window.attachEvent('onload',doReady);
    }
    /*Webkit*/
    else if (Browser.cores.webKit && Browser.version < 525){
        (function(){
            if( isReady ) return;
            if (/loaded|complete/.test(document.readyState))
                doReady();
            else
                setTimeout( arguments.callee, 0 );
        })();
        window.addEventListener('load',doReady,false);
    }
    /*FF Opera 高版webkit 其他*/
    else{
        if( !Browser.cores.ff || Browser.version != 2 || this.conf.enableMozDOMReady)
            document.addEventListener( "DOMContentLoaded", function(){
                document.removeEventListener( "DOMContentLoaded", arguments.callee, false );
                doReady();
            }, false );
        window.addEventListener('load',doReady,false);
    }
}

/////////////页面性能统计/////////////////////////////////////////////////////

// 计算加载时间  https://www.jianshu.com/p/70380e750c04
function getPerformanceTiming () {
    var performance = window.performance;

    if (!performance) {
        // 当前浏览器不支持
        console.log('你的浏览器不支持 performance 接口');
        return {};
    }

    var t = performance.timing;
    var times = {};

    //【重要】页面加载完成的时间
    //【原因】这几乎代表了用户等待页面可用的时间
    times.loadPage = t.loadEventEnd - t.navigationStart;//过早获取时,loadEventEnd有时会是0
    
    if(times.loadPage <= 0) {
        setTimeout(function(){
        	submit(getPerformanceTiming());
        }, 100);
        return;
    }

    //【重要】解析 DOM 树结构的时间
    //【原因】反省下你的 DOM 树嵌套是不是太多了！
    times.domReady = t.domComplete - t.responseEnd;

    //【重要】重定向的时间
    //【原因】拒绝重定向！比如，http://example.com/ 就不该写成 http://example.com
    times.redirect = t.redirectEnd - t.redirectStart;

    //【重要】DNS 查询时间
    //【原因】DNS 预加载做了么？页面内是不是使用了太多不同的域名导致域名查询的时间太长？
    // 可使用 HTML5 Prefetch 预查询 DNS ，见：[HTML5 prefetch](http://segmentfault.com/a/1190000000633364)
    times.lookupDomain = t.domainLookupEnd - t.domainLookupStart;

    //【重要】读取页面第一个字节的时间
    //【原因】这可以理解为用户拿到你的资源占用的时间，加异地机房了么，加CDN 处理了么？加带宽了么？加 CPU 运算速度了么？
    // TTFB 即 Time To First Byte 的意思
    // 维基百科：https://en.wikipedia.org/wiki/Time_To_First_Byte
    times.ttfb = t.responseStart - t.navigationStart;

    //【重要】内容加载完成的时间
    //【原因】页面内容经过 gzip 压缩了么，静态资源 css/js 等压缩了么？
    times.request = t.responseEnd - t.requestStart;

    //【重要】执行 onload 回调函数的时间
    //【原因】是否太多不必要的操作都放到 onload 回调函数里执行了，考虑过延迟加载、按需加载的策略么？
    times.loadEvent = t.loadEventEnd - t.loadEventStart;

    // DNS 缓存时间
    times.appcache = t.domainLookupStart - t.fetchStart;

    // 卸载页面的时间
    times.unloadEvent = t.unloadEventEnd - t.unloadEventStart;

    // TCP 建立连接完成握手的时间
    times.connect = t.connectEnd - t.connectStart;

    return times;
}
//页面加载完毕后上报后台
onDOMContentLoaded(function () {
    submit(getPerformanceTiming());
})




///////////资源加载统计///////////////////////////////////////////////////////


//计算单个资源加载时间
function getEntryTiming (entry) {
    if (!entry) {
        // 当前浏览器不支持
        console.log('参数错误');
        return;
    }
    var t = entry;
    var times = {};

    // 重定向的时间
    times.redirect = t.redirectEnd - t.redirectStart;

    // DNS 查询时间
    times.lookupDomain = t.domainLookupEnd - t.domainLookupStart;

    // 内容加载完成的时间
    times.request = t.responseEnd - t.requestStart;

    // TCP 建立连接完成握手的时间
    times.connect = t.connectEnd - t.connectStart;

    // 挂载 entry 返回
    times.name = entry.name;
    times.entryType = entry.entryType;
    times.initiatorType = entry.initiatorType;
    times.duration = entry.duration;

    return times;
}
//计算所有资源资源加载时间
function getEntriesTiming(){
    if (!window.performance) {
        // 当前浏览器不支持
        console.log('你的浏览器不支持 performance 接口');
        return;
    }
    var result = [];
    var entries = window.performance.getEntries();
    entries.forEach(function (entry) {
        var entryTiming = getEntryTiming(entry);
        result.push(entryTiming)
    });
    return result
}
//所有资源加载完毕统计上报后台
window.onload=function(){
    //submit(getEntriesTiming())
}